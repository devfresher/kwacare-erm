function t(t, i) {
    if (!t) throw new Error(i)
}

class i {
    static invokeAndIgnoreExceptions(t) {
        try {
            t()
        } catch (t) {
            console.log("Ignoring exception in user callback: " + t)
        }
    }
}

class s {
    constructor(t) {
        this.t = t, this.i = "", this.h = new TextDecoder("utf-8"), this.o = !1
    }

    cancel() {
        this.t.cancel()
    }

    eof() {
        return this.o
    }

    l() {
        const t = this.i.indexOf("\r\n");
        if (-1 == t) return null;
        const i = this.i.substr(0, t);
        return this.i = this.i.substr(t + 2), i
    }

    u() {
        return this.t.read().then(t => {
            if (t.done) return this.o = !0, Promise.resolve(this.i);
            this.i += this.h.decode(t.value);
            const i = this.l();
            return i ? Promise.resolve(i) : this.u()
        })
    }

    readEvent() {
        if (this.o) return Promise.reject();
        const t = this.l();
        return t ? Promise.resolve(t) : this.u()
    }
}

class e {
    constructor(t) {
        this._ = t
    }

    p(t, i) {
        return fetch(this._ + t, {
            method: "POST",
            cache: "no-cache",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(i)
        }).then(t => t.ok ? t.json() : Promise.reject(t.status))
    }

    v(t, i) {
        return fetch(this._ + t, {
            method: "POST",
            cache: "no-cache",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(i)
        })
    }

    createBridge(t, i, s) {
        const e = {userId: t, passwordHash: i, type: s};
        return fetch(this._ + "/client/createBridge", {
            method: "POST",
            cache: "no-cache",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(e)
        })
    }

    invite(t) {
        return this.v("/client/invite", {callId: t})
    }

    call(t, i, s) {
        return this.p("/client/call", {callerId: t, calleeId: i, isScreenSharing: s})
    }

    accept(t, i) {
        return this.v("/client/accept", {callId: t, token: i})
    }

    reject(t, i) {
        return this.v("/client/reject", {callId: t, token: i})
    }

    offer(t, i, s) {
        return this.v("/client/offer", {callId: t, sdp: s, token: i})
    }

    answer(t, i, s) {
        return this.v("/client/answer", {callId: t, sdp: s, token: i})
    }

    ice(t, i, s) {
        return this.v("/client/ice", {callId: t, candidate: i, token: s})
    }

    end(t, i) {
        return this.v("/client/end", {callId: t, token: i})
    }
}

const h = new class {
    constructor() {
        this.g = [], this.I = 0, this.m = -1
    }

    C() {
        this.g.forEach(t => t.func())
    }

    k() {
        this.m = setInterval(() => this.C(), 1e3)
    }

    S() {
        clearInterval(this.m), this.m = -1
    }

    addTask(t) {
        const i = this.I++, s = {id: i, func: t};
        return this.g.push(s), 1 == this.g.length && this.k(), i
    }

    removeTask(t) {
        const i = this.g.findIndex(i => i.id == t);
        -1 != i && (this.g.splice(i, 1), 0 == this.g.length && this.S())
    }
}, n = new class {
    newAudioContext() {
        return new (window.AudioContext || window.webkitAudioContext)
    }
};

class r {
    constructor() {
        this.P = -1, this.V = n.newAudioContext(), this.T = this.V.createAnalyser(), this.T.fftSize = 2048, this.A = new Uint8Array(this.T.frequencyBinCount), this.L = null, this.db = 0, this.ondbthresholdexceeded = t => {
        }, this.dbthreshold = 65
    }

    connect(t) {
        -1 == this.P && (this.P = h.addTask(() => this.j())), this.L && this.L.disconnect(), this.L = this.V.createMediaStreamSource(t), this.L.connect(this.T)
    }

    disconnect() {
        -1 != this.P && (h.removeTask(this.P), this.L.disconnect(), this.L = null, this.P = -1)
    }

    j() {
        const t = this.A.length;
        let s = 0;
        this.T.getByteTimeDomainData(this.A);
        for (let i = 0; i < t; i++) {
            const t = .0078125 * (this.A[i] - 128);
            s += t * t
        }
        this.db = 10 * Math.log10(s / t), console.log("db=" + this.db), this.db >= this.dbthreshold && i.invokeAndIgnoreExceptions(() => this.ondbthresholdexceeded(this))
    }
}

class a {
    constructor(t) {
        this.B = t.isInbound, this.O = t.isScreenSharing, this.U = t.remotePartyId, this.R = t.bridge, this.M = t.callId, this.N = t.config, this.D = t.token, this.J = null, this.H = null, this.K = null, this.t = null, this.F = null, this.G = null, this.W = [], t.isInbound ? this.q = 1 : this.q = 0, this.oncallstarted = t => this.X("Unhandled event: call started: " + t.M), this.oncallrejected = t => this.X("Unhandled event: call rejected: " + t.M), this.oncallended = t => this.X("Unhandled event: call ended: " + t.M), this.onstreamupdated = (t, i) => this.X("Unhandled event: stream updated: " + t.M), this.onparticipantlistupdated = (t, i) => this.X("Unhandled event: participant list updated: " + t.M), this.onviewportlayoutupdated = (t, i) => this.X("Unahndled event: viewport layout updated: " + i), this.onfacialrecognizerresults = (t, i) => this.X("Unhandled event: facial recognizer results: " + i)
    }

    Y(t) {
        console.log("VC/" + this.M + ": " + t)
    }

    Z(t) {
        console.error("VC/" + this.M + ": " + t)
    }

    X(t) {
        console.warn("VC/" + this.M + ": " + t)
    }

    $() {
        return this.J = new RTCPeerConnection(this.N), this.J.onicecandidate = t => this.tt(t), this.J.ontrack = t => this.it(t), this.O ? this.B ? Promise.resolve(this) : this.st() : this.et()
    }

    et() {
        return this.R.getLocalMediaStream().then(t => {
            t.getTracks().forEach(i => this.J.addTrack(i, t))
        })
    }

    st() {
        return navigator.mediaDevices.getDisplayMedia({video: {cursor: "always"}, audio: !0}).then(t => {
            t.getTracks().forEach(i => this.J.addTrack(i, t))
        })
    }

    ht() {
        this.K && (this.K.disconnect(), this.K = null), this.q = 6, this.R.nt(this), this.J.close()
    }

    rt(i) {
        switch (t("CALL" == i.type, 'Bad event type. "CALL" expected.'), i.name) {
            case"accept":
                this.at();
                break;
            case"end":
                this.ot();
                break;
            case"reject":
                this.ct();
                break;
            case"sdp":
                this.lt(i.sdp, i.action);
                break;
            case"ice":
                this.dt(i.iceCandidate);
                break;
            case"participants":
                this.ut(i.userIds);
                break;
            case"viewportLayout":
                this._t({frameWidth: i.frameWidth, frameHeight: i.frameHeight, viewports: i.viewports});
                break;
            case"facialRecognition":
                this.vt({callId: i.tagCallId, tag: i.tag, confidence: i.confidence});
                break;
            default:
                throw new Error("Bad call state")
        }
    }

    ut(t) {
        this.F = t, i.invokeAndIgnoreExceptions(() => this.onparticipantlistupdated(this, this.F))
    }

    _t(t) {
        this.G = t, i.invokeAndIgnoreExceptions(() => this.onviewportlayoutupdated(this, this.G))
    }

    vt(t) {
        i.invokeAndIgnoreExceptions(() => this.onfacialrecognizerresults(this, t))
    }

    dt(t) {
        this.J.remoteDescription ? this.J.addIceCandidate(t) : this.W.push(t)
    }

    it(t) {
        this.t = t.streams[0], this.K && this.K.connect(this.t), i.invokeAndIgnoreExceptions(() => this.onstreamupdated(this, this.t))
    }

    ot() {
        i.invokeAndIgnoreExceptions(() => this.oncallended(this)), this.ht()
    }

    at() {
        this.J.createOffer({
            offerToReceiveVideo: !0,
            offerToReceiveAudio: !0
        }).then(t => this.J.setLocalDescription(t)).then(() => this.R.gt.offer(this.M, this.D, this.J.localDescription.sdp)).catch(t => {
            throw this.bt(t), t
        }), i.invokeAndIgnoreExceptions(() => this.oncallstarted(this))
    }

    ct() {
        this.R.nt(this), this.q = 4, i.invokeAndIgnoreExceptions(() => this.oncallrejected(this))
    }

    lt(t, i) {
        const s = new RTCSessionDescription({type: i, sdp: t});
        "offer" == i ? this.J.setRemoteDescription(s).then(() => (this.ft(), this.J.createAnswer())).then(t => this.J.setLocalDescription(t)).then(() => this.R.gt.answer(this.M, this.D, this.J.localDescription.sdp)).then(t => (this.q = 3, t)).catch(t => {
            throw this.bt(t), t
        }) : "answer" == i && this.J.setRemoteDescription(s).then(() => {
            this.ft(), this.q = 3
        }).catch(t => {
            throw this.bt(t), t
        })
    }

    ft() {
        this.W.forEach(t => {
            this.J.addIceCandidate(t)
        }), this.W = []
    }

    tt(t) {
        if (t.candidate) try {
            this.R.gt.ice(this.M, t.candidate, this.D)
        } catch (t) {
            this.X("failed to transmit ICE candidate")
        }
    }

    bt(t) {
        this.q = 4, this.Z("panic: " + t.message)
    }

    getParticipantList() {
        return this.F
    }

    getViewportLayout() {
        return this.G
    }

    getCallId() {
        return this.M
    }

    getVideoBridge() {
        return this.R
    }

    getRemotePartyId() {
        return this.U
    }

    isInbound() {
        return this.B
    }

    setUserData(t) {
        this.H = t
    }

    getUserData() {
        return this.H
    }

    attachActivityMonitor(s, e) {
        t(null == this.K, "Activity notifier already attached"), t(null != e, "Activity monitor callback not defined"), this.K = new r, this.K.dbtheshold = s, this.K.ondbthresholdexceeded = t => i.invokeAndIgnoreExceptions(() => e(this)), this.t && this.K.connect(this.t)
    }

    getSoundLevel() {
        return this.K || this.K.db
    }

    start() {
        return t(0 == this.q, "Call already initialized"), this.q = 1, this.Y("starting"), this.R.gt.call(this.R.getUserId(), this.U, this.O).then(t => (this.M = t.callId, this.N = t.config, this.D = t.token, this.$())).then(() => this.R.gt.invite(this.M)).then(() => (this.q = 2, this.R.wt(this), this)).catch(t => {
            throw this.bt(t), t
        })
    }

    accept() {
        return t(1 == this.q, "Invalid call state"), this.Y("accepting"), this.$().then(() => this.R.gt.accept(this.M, this.D)).then(t => (this.q = 2, this)).catch(t => {
            throw this.bt(t), t
        })
    }

    reject() {
        return t(1 == this.q, "Invalid call state"), this.Y("rejecting"), this.R.gt.reject(this.M, this.D).then(t => (this.q = 5, this.R.nt(this), this)).catch(t => {
            throw this.bt(t), t
        })
    }

    stop() {
        return 6 != this.q && 4 != this.q ? (this.ht(), this.R.gt.end(this.M, this.D).then(() => this)) : Promise.resolve(this)
    }

    muteRemoteAudio(i) {
        t("boolean" == typeof i, "Expected a boolean value"), this.J.getReceivers().forEach(t => {
            "audio" == t.track.kind && (t.track.enabled = i)
        })
    }
}

class o {
    constructor(t) {
        this.It = t.userId, this.yt = t.type, this.Ct = t.passwordHash, this.gt = new e(t.serviceUrl || ""), this.kt = !1, this.St = {}, this.Et = !1, this.Pt = !1, this.Vt = null, this.Tt = null, this.onbridgeactive = t => console.log("onbridgeactive event not handled"), this.onbridgeinactive = t => console.log("onbridgeinactive event not handled"), this.onbridgefailure = t => console.log("onbridgefailure event not handled"), this.onincomingcall = t => {
            console.log("Inbound call event not handled; call rejected."), t.reject()
        }
    }

    bt(t) {
        console.log("Catastrophic bridge failure: " + t), i.invokeAndIgnoreExceptions(() => this.onbridgefailure(this)), this.shutdown()
    }

    At() {
        this.kt ? this.bt(new Error("Event stream closed unexpectedly")) : (i.invokeAndIgnoreExceptions(() => this.onbridgeinactive(this)), this.shutdown())
    }

    Lt() {
        this.Vt.readEvent().then(t => {
            if (this.Vt.eof()) this.At(); else {
                try {
                    const i = JSON.parse(t);
                    this.rt(i)
                } catch (t) {
                    return void this.bt(t)
                }
                this.Lt()
            }
        })
    }

    jt(t) {
        const i = this.St[t.callId];
        i ? i.rt(t) : console.log("Invalid call identifier in the event stream: " + t.callId)
    }

    Bt(t) {
        const s = new a({
            bridge: this,
            callId: t.callId,
            isInbound: !0,
            isScreenSharing: t.isScreenSharing,
            remotePartyId: t.callerId,
            config: t.config,
            token: t.token
        });
        this.wt(s), i.invokeAndIgnoreExceptions(() => this.onincomingcall(s))
    }

    Ot(t) {
        this.kt || (this.kt = !0, i.invokeAndIgnoreExceptions(() => this.onbridgeactive(this)))
    }

    rt(t) {
        switch (console.log(t), t.type) {
            case"INCOMING":
                this.Bt(t);
                break;
            case"KEEPALIVE":
                this.Ot(t);
                break;
            case"CALL":
                this.jt(t);
                break;
            default:
                this.bt(new Error("Bad event type: " + t.type + ". Corrupt stream?"))
        }
    }

    Ut() {
        Object.values(this.St).forEach(t => t.ht()), this.St = {}
    }

    wt(t) {
        this.St[t.getCallId()] = t
    }

    nt(t) {
        const i = t.getCallId();
        this.St.hasOwnProperty(i) && delete this.St[i]
    }

    getUserId() {
        return this.It
    }

    getCalls() {
        return Object.values(this.St)
    }

    hasCamera() {
        return this.Et
    }

    hasMicrophone() {
        return this.Pt
    }

    getCallById(t) {
        return this.St[t]
    }

    isActive() {
        return this.kt
    }

    getLocalMediaStream() {
        return t(this.kt, "VideoBridge not active"), this.Tt ? Promise.resolve(this.Tt) : navigator.mediaDevices.enumerateDevices().then(t => {
            var i = {};
            return null != t.find(t => "videoinput" == t.kind) && (this.Et = !0, i.video = {
                width: 800,
                height: 600
            }), null != t.find(t => "audioinput" == t.kind) && (this.Pt = !0, i.audio = {channels: 1}), navigator.mediaDevices.getUserMedia(i)
        }).then(t => (this.Tt = t, t))
    }

    closeLocalMediaStream() {
        t(this.kt, "VideoBridge not active"), this.Tt && (this.Tt.getTracks().forEach(t => t.stop()), this.Tt = null, this.Pt = !1, this.Et = !1)
    }

    enableCamera(i) {
        t(this.kt, "Video bridge not active"), t("boolean" == typeof i, "Expected a boolean value"), this.Et && this.Tt.getTracks().forEach(t => {
            "live" == t.readyState && "video" === t.kind && (t.enabled = i)
        })
    }

    enableMicrophone(i) {
        t(this.kt, "Video bridge not active"), t("boolean" == typeof i, "Expected a boolean value"), this.Pt && this.Tt.getTracks().forEach(t => {
            "live" == t.readyState && "audio" === t.kind && (t.enabled = i)
        })
    }

    start() {
        t(!this.kt, "Video bridge already active"), this.gt.createBridge(this.It, this.Ct, this.yt).then(t => t.body).then(t => {
            this.Vt = new s(t.getReader()), this.Lt()
        }).catch(t => {
            console.error("Video bridge creation failure: " + t), i.invokeAndIgnoreExceptions(() => this.onbridgefailure(this)), this.bt(t)
        })
    }

    shutdown() {
        t(this.kt, "Video bridge not active"), Object.values(this.St).forEach(t => t.stop()), this.St = {}, this.Vt.cancel(), this.closeLocalMediaStream(), this.kt = !1
    }

    createVideoCall(i) {
        return t(this.kt, "Video bridge not active"), new a({
            bridge: this,
            isInbound: !1,
            isScreenSharing: !1,
            remotePartyId: i
        })
    }

    createScreenSharingCall(i) {
        return t(this.kt, "Video bridge not activbe"), new a({
            bridge: this,
            isInboud: !1,
            isScreenSharing: !0,
            remotePartyId: i
        })
    }
}

export {o as VideoBridge, a as VideoCall};